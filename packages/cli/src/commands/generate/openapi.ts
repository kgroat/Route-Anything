import { Command } from 'commander'
import chalk from 'chalk'
import { Project, SourceFile } from 'ts-morph'
import {
  anySchema,
  findAnyReferences,
  getRoutersFromProgram,
} from '@any-router/openapi'
import { OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'
import { extname, join } from 'node:path'
import { writeFileSync } from 'node:fs'
import { Document } from 'yaml'
import {
  transformerSymbol,
  defaultTransformer,
  OpenapiTransformer,
} from '@any-router/openapi/transformer'
import { getCompiledMeta } from '@any-router/core/protected'

type Flags = {
  files: string
  transformer: string | null | undefined
}

function mapToHttpMethod(method: string): OpenAPIV3_1.HttpMethods | null {
  switch (method) {
    case 'GET':
      return OpenAPIV3.HttpMethods.GET
    case 'POST':
      return OpenAPIV3.HttpMethods.POST
    case 'PUT':
      return OpenAPIV3.HttpMethods.PUT
    case 'DELETE':
      return OpenAPIV3.HttpMethods.DELETE
    case 'PATCH':
      return OpenAPIV3.HttpMethods.PATCH
    case 'HEAD':
      return OpenAPIV3.HttpMethods.HEAD
    case 'OPTIONS':
      return OpenAPIV3.HttpMethods.OPTIONS
    default:
      return null
  }
}

function getFullSchema(
  program: SourceFile,
  tempFile: SourceFile,
  transformer: OpenapiTransformer,
): OpenAPIV3_1.Document {
  const meta = getCompiledMeta()

  if (!meta) {
    throw new Error('Could not find compiled meta')
  }

  const compileOptions = meta.compileOptions

  const pathsObject: OpenAPIV3_1.PathsObject = {}

  const doc: OpenAPIV3_1.Document = {
    openapi: '3.1.0',
    info: compileOptions.openapi.info,
    servers: compileOptions.openapi.servers,
    components: compileOptions.openapi.components,
    paths: pathsObject,
  }

  const routersByPath = getRoutersFromProgram(program, tempFile)
  for (const [path, routers] of routersByPath.entries()) {
    const pathObject: OpenAPIV3_1.PathItemObject = (pathsObject[path] = {})
    for (const router of routers) {
      const httpMethod = mapToHttpMethod(router.method)
      if (!httpMethod) {
        continue
      }

      pathObject[httpMethod] = {
        responses: transformer.getResponses(router),
      } satisfies OpenAPIV3_1.OperationObject as OpenAPIV3_1.OperationObject &
        OpenAPIV3.OperationObject
    }
  }

  const anyRefs = findAnyReferences(pathsObject, 'paths')
  if (anyRefs.length > 0) {
    console.warn(
      chalk.bold.yellow('WARNING:'),
      chalk.yellow('Found `any` types that ended up in the schema:'),
    )
    anyRefs.forEach((ref) => console.warn(chalk.yellow(`  - ${ref}`)))
    console.warn(
      chalk.yellow(
        '\nThese `any` types might not be correct -- try fixing them with explicit type declarations',
      ),
    )
    console.warn(
      chalk.yellow('These can lead to unsafe or unexpected behaviour'),
    )

    doc.components = {
      ...doc.components,
      schemas: {
        ...doc.components?.schemas,
        any: anySchema,
      },
    }
  }

  return doc
}

async function generateOpenApi(
  inputPath: string,
  outputPath: string,
  { files, transformer }: Flags,
) {
  let transformerObject: OpenapiTransformer
  if (transformer) {
    let transformerModule: any
    if (transformer.startsWith('.')) {
      transformerModule = await import(join(process.cwd(), transformer))
    } else {
      transformerModule = await import(transformer)
    }

    transformerObject = transformerModule.default ?? transformerModule

    if (!transformerObject || !transformerObject[transformerSymbol]) {
      throw new Error(
        `Could not find a default export in ${transformer} which is a valid transformer. Did you forget to export one?`,
      )
    }
  } else {
    transformerObject = defaultTransformer
  }

  const project = new Project()
  project.addSourceFilesAtPaths(files.split(','))

  const program = project.getSourceFileOrThrow(inputPath)
  const tempFile = project.createSourceFile(
    `__temp__${new Date().toISOString()}__.ts`,
    '',
  )

  await import(program.getFilePath())

  const fullSchema = getFullSchema(program, tempFile, transformerObject)

  if (extname(outputPath) === '.yaml') {
    const yamlDoc = new Document(fullSchema)
    yamlDoc.commentBefore = ' This file was generated by @any-router/cli'

    writeFileSync(outputPath, yamlDoc.toString())
  } else {
    writeFileSync(outputPath, JSON.stringify(fullSchema, null, 2))
  }

  process.exit(0)
}

export default (command: Command) => {
  command
    .argument('programPath', 'Path to the entrypiont to your handler')
    .argument('outputPath', 'Path to the file to generate')
    .option(
      '-f, --files [files]',
      'Globs to the files to generate',
      'src/**/*.ts',
    )
    .option(
      '-t, --transformer [transformer]',
      'Path to (or module name of) the transformer to use',
    )
    .action(generateOpenApi)

  return command
}
