import { Command } from 'commander'
import { Project, SourceFile } from 'ts-morph'
import { getRoutersFromProgram } from '@any-router/openapi/getRouters'
import { OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'
import { extname, join } from 'node:path'
import { writeFileSync } from 'node:fs'
import { Document } from 'yaml'
import {
  transformerSymbol,
  defaultTransformer,
  OpenapiTransformer,
} from '@any-router/openapi/transformer'

type Flags = {
  files: string
  transformer: string | null | undefined
}

function mapToHttpMethod(method: string): OpenAPIV3_1.HttpMethods | null {
  switch (method) {
    case 'GET':
      return OpenAPIV3.HttpMethods.GET
    case 'POST':
      return OpenAPIV3.HttpMethods.POST
    case 'PUT':
      return OpenAPIV3.HttpMethods.PUT
    case 'DELETE':
      return OpenAPIV3.HttpMethods.DELETE
    case 'PATCH':
      return OpenAPIV3.HttpMethods.PATCH
    case 'HEAD':
      return OpenAPIV3.HttpMethods.HEAD
    case 'OPTIONS':
      return OpenAPIV3.HttpMethods.OPTIONS
    default:
      return null
  }
}

function getFullSchema(
  program: SourceFile,
  tempFile: SourceFile,
  transformer: OpenapiTransformer,
): OpenAPIV3_1.Document {
  const pathsObject: OpenAPIV3_1.PathsObject = {}

  const doc: OpenAPIV3_1.Document = {
    openapi: '3.1.0',
    info: {
      title: 'API',
      version: '1.0.0',
    },
    components: {},
    paths: pathsObject,
  }

  const routersByPath = getRoutersFromProgram(program, tempFile)
  for (const [path, routers] of routersByPath.entries()) {
    const pathObject: OpenAPIV3_1.PathItemObject = (pathsObject[path] = {})
    for (const router of routers) {
      const httpMethod = mapToHttpMethod(router.method)
      if (!httpMethod) {
        continue
      }

      pathObject[httpMethod] = {
        responses: transformer.getResponses(router),
      } satisfies OpenAPIV3_1.OperationObject as OpenAPIV3_1.OperationObject &
        OpenAPIV3.OperationObject
    }
  }

  return doc
}

function generateOpenApi(
  inputPath: string,
  outputPath: string,
  { files, transformer }: Flags,
) {
  let transformerObject: OpenapiTransformer
  if (transformer) {
    let transformerModule: any
    if (transformer.startsWith('.')) {
      transformerModule = require(join(process.cwd(), transformer))
    } else {
      transformerModule = require(transformer)
    }

    transformerObject = transformerModule.default ?? transformerModule

    if (!transformerObject || !transformerObject[transformerSymbol]) {
      throw new Error(
        `Could not find a default export in ${transformer} which is a valid transformer. Did you forget to export one?`,
      )
    }
  } else {
    transformerObject = defaultTransformer
  }

  const project = new Project()
  project.addSourceFilesAtPaths(files.split(','))
  const program = project.getSourceFileOrThrow(inputPath)
  const tempFile = project.createSourceFile(
    `__temp__${new Date().toISOString()}__.ts`,
    '',
  )

  const fullSchema = getFullSchema(program, tempFile, transformerObject)

  if (extname(outputPath) === '.yaml') {
    const yamlDoc = new Document(fullSchema)
    yamlDoc.commentBefore = ' This file was generated by @any-router/cli'

    writeFileSync(outputPath, yamlDoc.toString())
  } else {
    writeFileSync(outputPath, JSON.stringify(fullSchema, null, 2))
  }
}

export default (command: Command) => {
  command
    .argument('programPath', 'Path to the entrypiont to your handler')
    .argument('outputPath', 'Path to the file to generate')
    .option(
      '-f, --files [files]',
      'Globs to the files to generate',
      'src/**/*.ts',
    )
    .option(
      '-t, --transformer [transformer]',
      'Path to (or module name of) the transformer to use',
    )
    .action(generateOpenApi)

  return command
}
